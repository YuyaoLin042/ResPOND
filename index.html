<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ResPOND â€“ Gentle Lake</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(to top, #045e54, #a5e3d8);
      height: 100vh;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    #overlay {
      position: absolute;
      top: 30px;
      left: 40px;
      color: white;
    }
    #overlay h1 {
      font-size: 32px;
      margin: 0;
    }
    #overlay p {
      margin: 4px 0;
      font-size: 14px;
      opacity: 0.8;
    }
    #controls {
      position: absolute;
      top: 30px;
      right: 40px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #controls button {
      padding: 10px 16px;
      font-size: 14px;
      background-color: #2e73f7;
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="pondCanvas"></canvas>
  <div id="overlay">
    <h1>ResPOND</h1>
    <p>Gentle aquatic feedback</p>
    <p>Connected Points: <span id="pointsCount">0</span></p>
    <p>Motor Trigger Count: <span id="motorCount">0</span></p>
  </div>
  <div id="controls">
    <button id="bleButton">Connect Device</button>
    <button id="fullscreenButton">Fullscreen</button>
  </div>

  <script>
    const canvas = document.getElementById("pondCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    const waveLayers = 10;
    const wavePoints = 80;
    const waveAmplitude = 10;
    const waveSpeed = 0.003;
    let wavePhase = 0;
    const fishPositions = [
      { x: canvas.width * 0.3, y: 400 },
      { x: canvas.width * 0.5, y: 420 },
      { x: canvas.width * 0.7, y: 400 }
    ];
    const ripples = [];
    const pellets = [];
    const bubbles = [];
    let fishValues = [0, 0, 0];
    let lastFishValues = [0, 0, 0];
    let waveValue = 0;
    let vibration = 0;
    let motorTriggered = false;
    let motorTriggerCount = 0;
    let lastTrigger = false;

    const diffThreshold = 4.0;
    const vibrationThreshold = 20;
    const requiredFishTriggers = 2;

    // BLE setup (unchanged)
    const bleButton = document.getElementById('bleButton');
    const fullscreenButton = document.getElementById('fullscreenButton');
    const pointsCountSpan = document.getElementById('pointsCount');
    const motorCountSpan = document.getElementById('motorCount');

    let bleDevice = null;
    let bleCharacteristic = null;

    bleButton.onclick = async () => {
      if (!bleDevice) {
        try {
          const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: ['0000ffe0-0000-1000-8000-00805f9b34fb'] }]
          });
          bleDevice = device;
          const server = await device.gatt.connect();
          const service = await server.getPrimaryService('0000ffe0-0000-1000-8000-00805f9b34fb');
          bleCharacteristic = await service.getCharacteristic('0000ffe1-0000-1000-8000-00805f9b34fb');
          await bleCharacteristic.startNotifications();
          bleCharacteristic.addEventListener('characteristicvaluechanged', handleData);
          bleButton.textContent = 'Disconnect Device';
        } catch (e) {
          alert('BLE Connection Failed: ' + e);
        }
      } else {
        if (bleDevice.gatt.connected) bleDevice.gatt.disconnect();
        bleDevice = null;
        bleCharacteristic = null;
        bleButton.textContent = 'Connect Device';
      }
    };

    fullscreenButton.onclick = () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        fullscreenButton.textContent = 'Exit Fullscreen';
      } else {
        document.exitFullscreen();
        fullscreenButton.textContent = 'Fullscreen';
      }
    };

    function handleData(event) {
      const value = new TextDecoder().decode(event.target.value).trim();
      const parts = value.split(',');
      if (parts.length === 5) {
        waveValue = parseFloat(parts[0]);
        for (let i = 0; i < 3; i++) {
          fishValues[i] = parseFloat(parts[i + 1]);
          if (Math.abs(fishValues[i] - lastFishValues[i]) > 0.5) {
            ripples.push(new Ripple(fishPositions[i].x, fishPositions[i].y));
          }
          lastFishValues[i] = fishValues[i];
        }
        vibration = parseInt(parts[4]);

        let mismatchCount = 0;
        for (let i = 0; i < 3; i++) {
          if (Math.abs(fishValues[i] - waveValue) > diffThreshold) mismatchCount++;
        }

        const newTrigger = (mismatchCount >= requiredFishTriggers && vibration > vibrationThreshold);
        if (newTrigger && !lastTrigger) {
          for (let i = 0; i < 6; i++) {
            pellets.push(new Pellet(Math.random() * canvas.width, -10));
          }
          motorTriggerCount++;
        }
        motorTriggered = newTrigger;
        lastTrigger = newTrigger;

        pointsCountSpan.textContent = fishValues.length;
        motorCountSpan.textContent = motorTriggerCount;
      }
    }

    class Ripple {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 4;
        this.alpha = 1;
      }
      update() {
        this.radius += 0.4;
        this.alpha -= 0.01;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(220,255,240,${this.alpha})`;
        ctx.lineWidth = 1.2;
        ctx.stroke();
      }
      isDone() {
        return this.alpha <= 0;
      }
    }

    class Pellet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.hit = false;
        this.alpha = 1;
      }
      update() {
        if (!this.hit) {
          this.y += 1.5;
          if (this.y > canvas.height * 0.6) {
            this.hit = true;
            for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
              bubbles.push(new Bubble(this.x + Math.random() * 10 - 5, this.y));
            }
          }
        } else {
          this.alpha -= 0.02;
        }
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
        ctx.fill();
      }
      isDone() {
        return this.alpha <= 0;
      }
    }

    class Bubble {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 3 + Math.random() * 5;
        this.alpha = 0.3 + Math.random() * 0.3;
        this.speed = 0.3 + Math.random();
      }
      update() {
        this.y -= this.speed;
        this.alpha -= 0.003;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
        ctx.fill();
      }
      isDone() {
        return this.alpha <= 0;
      }
    }

    function drawFish(x, y) {
      ctx.strokeStyle = '#d3f5e6';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x - 12, y);
      ctx.bezierCurveTo(x - 6, y - 6, x + 6, y - 6, x + 12, y);
      ctx.bezierCurveTo(x + 6, y + 6, x - 6, y + 6, x - 12, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x - 12, y);
      ctx.lineTo(x - 20, y - 5);
      ctx.moveTo(x - 12, y);
      ctx.lineTo(x - 20, y + 5);
      ctx.stroke();
    }

    function drawWaves() {
      wavePhase += waveSpeed;
      for (let j = 0; j < waveLayers; j++) {
        const yBase = canvas.height * 0.5 + j * 10;
        const alpha = 0.07 + j * 0.06;
        const dotSize = 1.5 + j * 0.3;

        for (let i = 0; i < wavePoints; i++) {
          const x = (i / wavePoints) * canvas.width;
          const y = yBase + Math.sin(i * 0.2 + wavePhase + j * 0.3) * waveAmplitude;
          ctx.beginPath();
          ctx.arc(x, y, dotSize, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.fill();
        }
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWaves();

      for (let i = 0; i < fishPositions.length; i++) {
        let p = fishPositions[i];
        const offset = Math.sin(Date.now() * 0.001 + i) * 8;
        drawFish(p.x + offset, p.y + Math.sin(Date.now() * 0.0015 + i) * 5);
      }

      for (let i = ripples.length - 1; i >= 0; i--) {
        ripples[i].update();
        ripples[i].draw();
        if (ripples[i].isDone()) ripples.splice(i, 1);
      }

      for (let i = pellets.length - 1; i >= 0; i--) {
        pellets[i].update();
        pellets[i].draw();
        if (pellets[i].isDone()) pellets.splice(i, 1);
      }

      for (let i = bubbles.length - 1; i >= 0; i--) {
        bubbles[i].update();
        bubbles[i].draw();
        if (bubbles[i].isDone()) bubbles.splice(i, 1);
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
