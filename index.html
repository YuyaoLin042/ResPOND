<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ResPOND Refined Swim</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100vh;
      font-family: "Helvetica Neue", sans-serif;
    }
    #container {
      display: flex;
      width: 100%;
      height: 100%;
    }
    #sidebar {
      width: 30%;
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border-right: 3px solid #369e8e;
      padding: 20px;
      box-sizing: border-box;
    }
    #sidebar h1 {
      font-size: 36px;
      margin: 10px 0;
    }
    #sidebar p {
      margin: 5px 0;
      font-size: 14px;
      opacity: 0.8;
    }
    .buttonBar {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 14px;
      background: #2e73f7;
      border: none;
      border-radius: 20px;
      color: #fff;
      cursor: pointer;
    }
    #main {
      width: 70%;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(to top, #0c3d3d, #4fd3c4);
    }
    .infoText {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.7;
    }
  </style>
</head>
<body>
<div id="container">
  <div id="sidebar">
    <h1>ResPOND</h1>
    <p>Visualizing calm in motion</p>
    <div class="buttonBar">
      <button id="bleButton">Connect Device</button>
      <button id="fullscreenButton">Fullscreen</button>
    </div>
    <p class="infoText">Connected points: <span id="pointsCount">0</span></p>
    <p class="infoText">Motor Trigger Count: <span id="motorCount">0</span></p>
  </div>
  <div id="main">
    <canvas id="pondCanvas"></canvas>
  </div>
</div>
<script>
const canvas = document.getElementById("pondCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth * 0.7;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth * 0.7;
  canvas.height = window.innerHeight;
});

let time = 0;
let ripples = [], bubbles = [], pellets = [];
let fishPositions = [
  { x: canvas.width * 0.25, y: canvas.height * 0.6, offset: Math.random() * 1000 },
  { x: canvas.width * 0.5, y: canvas.height * 0.6, offset: Math.random() * 1000 },
  { x: canvas.width * 0.75, y: canvas.height * 0.6, offset: Math.random() * 1000 }
];
let waveValue = 0, fishValues = [0,0,0], lastFishValues = [0,0,0], vibration = 0;
let motorTriggerCount = 0, lastTrigger = false, motorActive = false;
const diffThreshold = 4.0, vibrationThreshold = 20, requiredFishTriggers = 2;

// BLE
let bleDevice = null;
let bleCharacteristic = null;
const bleButton = document.getElementById('bleButton');
const fullscreenButton = document.getElementById('fullscreenButton');
const pointsCountSpan = document.getElementById('pointsCount');
const motorCountSpan = document.getElementById('motorCount');

bleButton.onclick = async () => {
  if (!bleDevice) {
    try {
      const device = await navigator.bluetooth.requestDevice({ filters: [{ services: ['0000ffe0-0000-1000-8000-00805f9b34fb'] }] });
      bleDevice = device;
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('0000ffe0-0000-1000-8000-00805f9b34fb');
      bleCharacteristic = await service.getCharacteristic('0000ffe1-0000-1000-8000-00805f9b34fb');
      await bleCharacteristic.startNotifications();
      bleCharacteristic.addEventListener('characteristicvaluechanged', handleData);
      bleButton.textContent = 'Disconnect Device';
    } catch (e) {
      alert('BLE Connection Failed: ' + e);
    }
  } else {
    if (bleDevice.gatt.connected) bleDevice.gatt.disconnect();
    bleDevice = null;
    bleCharacteristic = null;
    bleButton.textContent = 'Connect Device';
  }
};

fullscreenButton.onclick = () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    fullscreenButton.textContent = 'Exit Fullscreen';
  } else {
    document.exitFullscreen();
    fullscreenButton.textContent = 'Fullscreen';
  }
};

function handleData(event) {
  const value = new TextDecoder().decode(event.target.value).trim();
  const parts = value.split(',');
  if (parts.length === 5) {
    waveValue = parseFloat(parts[0]);
    for (let i = 0; i < 3; i++) {
      fishValues[i] = parseFloat(parts[i + 1]);
      if (Math.abs(fishValues[i] - lastFishValues[i]) > 0.5) {
        ripples.push({ x: fishPositions[i].x, y: fishPositions[i].y, r: 5, alpha: 1 });
      }
      lastFishValues[i] = fishValues[i];
    }
    vibration = parseInt(parts[4]);
    let mismatchCount = fishValues.filter(v => Math.abs(v - waveValue) > diffThreshold).length;
    let trigger = (mismatchCount >= requiredFishTriggers && vibration > vibrationThreshold);
    if (trigger && !lastTrigger) {
      motorActive = true;
      motorTriggerCount++;
    }
    if (!trigger && lastTrigger) {
      motorActive = false;
    }
    lastTrigger = trigger;
    pointsCountSpan.textContent = fishValues.length;
    motorCountSpan.textContent = motorTriggerCount;
  }
}

function drawWaves() {
  const lines = 10;
  const pointsPerLine = 60;
  for (let j = 0; j < lines; j++) {
    let yBase = canvas.height * 0.4 + j * 10;
    let alpha = 0.2 + 0.5 * (j / lines);
    let dotSize = 0.5 + 1.2 * (1 - j / lines);
    for (let i = 0; i < pointsPerLine; i++) {
      let x = (i / pointsPerLine) * canvas.width;
      let y = yBase + Math.sin((i * 0.3) + time + j * 0.5) * 6;
      ctx.beginPath();
      ctx.arc(x, y, dotSize, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fill();
    }
  }
}

function drawFish() {
  fishPositions.forEach((p, idx) => {
    const offsetY = Math.sin((time + p.offset) * 2) * 10;
    const offsetX = Math.cos((time + p.offset) * 1.5) * 10;
    const x = p.x + offsetX;
    const y = p.y + offsetY;
    ctx.beginPath();
    ctx.moveTo(x - 20, y);
    ctx.bezierCurveTo(x - 10, y - 10, x + 10, y - 10, x + 20, y);
    ctx.bezierCurveTo(x + 10, y + 10, x - 10, y + 10, x - 20, y);
    ctx.strokeStyle = 'white';
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x - 20, y);
    ctx.lineTo(x - 30, y - 8);
    ctx.moveTo(x - 20, y);
    ctx.lineTo(x - 30, y + 8);
    ctx.stroke();
  });
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWaves();
  drawFish();
  ripples.forEach((r, i) => {
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(220,255,240,${r.alpha})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    r.r += 1.2;
    r.alpha -= 0.01;
    if (r.alpha <= 0) ripples.splice(i, 1);
  });
  if (motorActive && time % 1 < 0.03) {
    for (let i = 0; i < 1; i++) {
      pellets.push({ x: Math.random() * canvas.width, y: -10, alpha: 1, hit: false });
    }
  }
  pellets.forEach((p, i) => {
    if (!p.hit && p.y >= canvas.height * 0.5) {
      p.hit = true;
      for (let j = 0; j < 4; j++) {
        bubbles.push({ x: p.x + Math.random()*20-10, y: canvas.height * 0.5, r: 4+Math.random()*4, alpha: 1, speed: 1+Math.random() });
      }
    }
    if (!p.hit) {
      p.y += 2;
    } else {
      p.alpha -= 0.02;
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
    ctx.fill();
    if (p.alpha <= 0) pellets.splice(i, 1);
  });
  bubbles.forEach((b, i) => {
    b.y -= b.speed;
    b.alpha -= 0.01;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,255,255,${b.alpha})`;
    ctx.stroke();
    if (b.alpha <= 0) bubbles.splice(i, 1);
  });
  time += 0.03;
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
