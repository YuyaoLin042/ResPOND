<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ResPOND BLE</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 30px;
      color: #ffffff;
      z-index: 10;
    }

    #ui h1 {
      font-size: 28px;
      margin: 0;
      font-weight: bold;
    }

    #ui p {
      font-size: 14px;
      margin: 4px 0;
    }

    #buttons {
      position: absolute;
      top: 20px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
    }

    button {
      background-color: #4e5cf5;
      color: white;
      border: none;
      padding: 10px 16px;
      font-size: 14px;
      border-radius: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>ResPOND</h1>
    <p>Points Count: <span id="pointsCount">0</span></p>
    <p>Motor Triggers: <span id="motorCount">0</span></p>
  </div>
  <div id="buttons">
    <button id="bleButton">Connect Device</button>
    <button id="fullscreenButton">Fullscreen</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script>
    let wavePhase = 0;
    let fishList = [];
    let ripples = [];
    let pellets = [];
    let bubbles = [];

    let waveValue = 0;
    let fishValues = [0, 0, 0];
    let lastFishValues = [0, 0, 0];
    let vibration = 0;
    let motorTriggerCount = 0;
    let lastTrigger = false;

    const diffThreshold = 4.0;
    const vibrationThreshold = 20;
    const requiredFishTriggers = 2;

    let bleDevice = null;
    let bleCharacteristic = null;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      for (let i = 0; i < 3; i++) {
        fishList.push(new Fish(width * (0.3 + i * 0.2), height * 0.6 + random(-10, 10)));
      }
    }

    function draw() {
      background(8, 122, 94);
      drawWaves();

      fishList.forEach(fish => fish.update());
      fishList.forEach(fish => fish.display());

      for (let i = ripples.length - 1; i >= 0; i--) {
        ripples[i].update();
        ripples[i].display();
        if (ripples[i].isDone()) ripples.splice(i, 1);
      }

      for (let i = pellets.length - 1; i >= 0; i--) {
        pellets[i].update();
        pellets[i].display();
        if (pellets[i].hitWater) {
          for (let j = 0; j < 3; j++) {
            bubbles.push(new Bubble(pellets[i].pos.x, height * 0.55));
          }
        }
        if (pellets[i].isDone()) pellets.splice(i, 1);
      }

      for (let i = bubbles.length - 1; i >= 0; i--) {
        bubbles[i].update();
        bubbles[i].display();
        if (bubbles[i].isDone()) bubbles.splice(i, 1);
      }
    }

    function drawWaves() {
      noStroke();
      fill(255, 255, 255, 30);
      for (let x = 0; x < width; x += 10) {
        for (let y = 0; y < 30; y++) {
          let yy = height * 0.5 +
                   6 * sin(x * 0.015 + wavePhase + y * 0.2) +
                   3 * cos(x * 0.01 + wavePhase * 1.2 + y * 0.3);
          let alpha = map(y, 0, 29, 80, 10);
          fill(255, alpha);
          ellipse(x, yy + y * 6, 4 - y * 0.08);
        }
      }
      wavePhase += 0.015;
    }

    class Fish {
      constructor(x, y) {
        this.base = createVector(x, y);
        this.offset = random(TWO_PI);
      }
      update() {
        this.pos = createVector(
          this.base.x + sin(frameCount * 0.01 + this.offset) * 10,
          this.base.y + cos(frameCount * 0.01 + this.offset) * 6
        );
      }
      display() {
        push();
        translate(this.pos.x, this.pos.y);
        stroke(240, 255, 240);
        strokeWeight(1.2);
        noFill();
        beginShape();
        vertex(-10, 0);
        bezierVertex(-4, -6, 4, -6, 10, 0);
        bezierVertex(4, 6, -4, 6, -10, 0);
        endShape();
        line(-10, 0, -16, -4);
        line(-10, 0, -16, 4);
        pop();
      }
    }

    class Pellet {
      constructor(x) {
        this.pos = createVector(x, -20);
        this.alpha = 255;
        this.hitWater = false;
      }
      update() {
        if (!this.hitWater) this.pos.y += 2.4;
        else this.alpha -= 3;
        if (this.pos.y > height * 0.55) this.hitWater = true;
      }
      display() {
        fill(255, this.alpha);
        noStroke();
        ellipse(this.pos.x, this.pos.y, 8, 8);
      }
      isDone() {
        return this.alpha <= 0;
      }
    }

    class Bubble {
      constructor(x, y) {
        this.pos = createVector(x, y);
        this.radius = random(4, 10);
        this.alpha = 150;
        this.speed = random(0.6, 1.5);
      }
      update() {
        this.pos.y -= this.speed;
        this.alpha -= 1.2;
      }
      display() {
        noStroke();
        fill(255, this.alpha);
        ellipse(this.pos.x, this.pos.y, this.radius);
      }
      isDone() {
        return this.alpha <= 0;
      }
    }

    // BLE
    document.getElementById("bleButton").onclick = async () => {
      if (!bleDevice) {
        try {
          const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: ["0000ffe0-0000-1000-8000-00805f9b34fb"] }]
          });
          bleDevice = device;
          const server = await device.gatt.connect();
          const service = await server.getPrimaryService("0000ffe0-0000-1000-8000-00805f9b34fb");
          bleCharacteristic = await service.getCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb");
          await bleCharacteristic.startNotifications();
          bleCharacteristic.addEventListener("characteristicvaluechanged", handleData);
          document.getElementById("bleButton").textContent = "Disconnect Device";
        } catch (e) {
          alert("Failed to connect: " + e);
        }
      } else {
        if (bleDevice.gatt.connected) bleDevice.gatt.disconnect();
        bleDevice = null;
        bleCharacteristic = null;
        document.getElementById("bleButton").textContent = "Connect Device";
      }
    };

    document.getElementById("fullscreenButton").onclick = () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        document.getElementById("fullscreenButton").textContent = "Exit Fullscreen";
      } else {
        document.exitFullscreen();
        document.getElementById("fullscreenButton").textContent = "Fullscreen";
      }
    };

    function handleData(event) {
      const value = new TextDecoder().decode(event.target.value).trim();
      const parts = value.split(',');
      if (parts.length === 5) {
        waveValue = parseFloat(parts[0]);
        for (let i = 0; i < 3; i++) {
          fishValues[i] = parseFloat(parts[i + 1]);
          if (Math.abs(fishValues[i] - lastFishValues[i]) > 0.5) {
            ripples.push(new Ripple(fishList[i].base.x, fishList[i].base.y));
          }
          lastFishValues[i] = fishValues[i];
        }
        vibration = parseInt(parts[4]);

        let mismatchCount = 0;
        for (let i = 0; i < 3; i++) {
          if (Math.abs(fishValues[i] - waveValue) > diffThreshold) {
            mismatchCount++;
          }
        }

        const newTrigger = (mismatchCount >= requiredFishTriggers && vibration > vibrationThreshold);
        if (newTrigger && !lastTrigger) {
          for (let i = 0; i < 8; i++) {
            pellets.push(new Pellet(random(width)));
          }
          motorTriggerCount++;
        }
        lastTrigger = newTrigger;

        document.getElementById("pointsCount").textContent = fishValues.length;
        document.getElementById("motorCount").textContent = motorTriggerCount;
      }
    }
  </script>
</body>
</html>
