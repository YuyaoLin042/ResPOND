<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ResPOND Visualization</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Segoe UI', sans-serif;
      color: #fff;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #sidebar {
      width: 26%;
      background: #0d0d0d;
      border-right: 3px solid #369e8e;
      padding: 40px 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #sidebar h1 {
      font-size: 36px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .authorName {
      font-size: 16px;
      color: #ccc;
      margin-bottom: 20px;
    }
    .buttonBar button {
      padding: 10px 20px;
      margin-bottom: 10px;
      background: #2c6fff;
      border: none;
      border-radius: 20px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      width: 100%;
    }
    .buttonBar button:hover {
      background: #1e4fbf;
    }
    .infoText {
      color: #aaa;
      font-size: 14px;
      margin-top: 20px;
      text-align: center;
    }
    #main {
      flex: 1;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background-color: #087a5e;
    }
  </style>
</head>
<body>
<div id="container">
  <div id="sidebar">
    <h1>ResPOND</h1>
    <div class="authorName">Sense, Respond, Empower</div>
    <div class="buttonBar">
      <button id="bleButton">Connect Device</button>
      <button id="fullscreenButton">Fullscreen</button>
    </div>
    <div class="infoText">Connected Points: <span id="pointsCount">0</span></div>
    <div class="infoText">Motor Trigger Count: <span id="motorCount">0</span></div>
  </div>
  <div id="main">
    <canvas id="pondCanvas"></canvas>
  </div>
</div>
<script>
const canvas = document.getElementById("pondCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth * 0.74;
canvas.height = window.innerHeight;

let fishPositions = [
  {x: canvas.width * 0.25, y: canvas.height * 0.65},
  {x: canvas.width * 0.5, y: canvas.height * 0.65},
  {x: canvas.width * 0.75, y: canvas.height * 0.65}
];

let wavePhase = 0, waveHeight = canvas.height * 0.7;
let ripples = [], pellets = [], bubbles = [];
let waveValue = 0, fishValues = [0,0,0], lastFishValues = [0,0,0];
let vibration = 0, motorTriggered = false, triggerCount = 0;
const diffThreshold = 4.0, vibrationThreshold = 20, requiredFishTriggers = 2;

let bleDevice = null, bleCharacteristic = null;

function drawFish(x, y) {
  ctx.strokeStyle = '#d3f5e6';
  ctx.beginPath();
  ctx.moveTo(x - 12, y);
  ctx.bezierCurveTo(x - 6, y - 6, x + 6, y - 6, x + 12, y);
  ctx.bezierCurveTo(x + 6, y + 6, x - 6, y + 6, x - 12, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - 12, y);
  ctx.lineTo(x - 20, y - 5);
  ctx.moveTo(x - 12, y);
  ctx.lineTo(x - 20, y + 5);
  ctx.stroke();
}

class Ripple {
  constructor(x, y) { this.x = x; this.y = y; this.r = 5; this.alpha = 1.0; }
  update() { this.r += 0.8; this.alpha -= 0.01; }
  display() {
    ctx.strokeStyle = `rgba(255,255,255,${this.alpha})`;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI); ctx.stroke();
  }
  isDone() { return this.alpha <= 0; }
}

class Pellet {
  constructor(x, y) { this.x = x; this.y = y; this.alpha = 1; this.hit = false; }
  update() {
    if (!this.hit) {
      this.y += 2;
      if (this.y >= waveHeight) {
        this.hit = true;
        for (let i = 0; i < 3; i++) bubbles.push(new Bubble(this.x + Math.random()*20-10, waveHeight));
      }
    } else {
      this.alpha -= 0.02;
    }
  }
  display() {
    ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
    ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 2*Math.PI); ctx.fill();
  }
  isDone() { return this.alpha <= 0; }
}

class Bubble {
  constructor(x, y) { this.x = x; this.y = y; this.r = 3 + Math.random()*5; this.alpha = 0.7; this.speed = 0.5 + Math.random(); }
  update() { this.y -= this.speed; this.alpha -= 0.005; }
  display() {
    ctx.strokeStyle = `rgba(255,255,255,${this.alpha})`;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI); ctx.stroke();
  }
  isDone() { return this.alpha <= 0; }
}

function drawLake() {
  wavePhase += 0.005;
  ctx.fillStyle = '#087a5e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
  ctx.moveTo(0, waveHeight);
  for (let x = 0; x <= canvas.width; x += 20) {
    let y = waveHeight + 6 * Math.sin(0.008 * x + wavePhase);
    ctx.lineTo(x, y);
  }
  ctx.lineTo(canvas.width, canvas.height);
  ctx.lineTo(0, canvas.height);
  ctx.closePath();
  ctx.fillStyle = '#065c49';
  ctx.fill();
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawLake();
  fishPositions.forEach(p => drawFish(p.x, p.y + Math.sin(Date.now() * 0.003 + p.x) * 3));
  ripples.forEach(r => r.update());
  ripples = ripples.filter(r => { r.display(); return !r.isDone(); });
  pellets.forEach(p => p.update());
  pellets = pellets.filter(p => { p.display(); return !p.isDone(); });
  bubbles.forEach(b => b.update());
  bubbles = bubbles.filter(b => { b.display(); return !b.isDone(); });
  requestAnimationFrame(animate);
}

function handleData(event) {
  const value = new TextDecoder().decode(event.target.value).trim();
  const parts = value.split(',');
  if (parts.length === 5) {
    waveValue = parseFloat(parts[0]);
    for (let i = 0; i < 3; i++) {
      fishValues[i] = parseFloat(parts[i + 1]);
      if (Math.abs(fishValues[i] - lastFishValues[i]) > 0.5) {
        ripples.push(new Ripple(fishPositions[i].x, waveHeight));
      }
      lastFishValues[i] = fishValues[i];
    }
    vibration = parseInt(parts[4]);
    let mismatchCount = fishValues.filter(v => Math.abs(v - waveValue) > diffThreshold).length;
    if (mismatchCount >= requiredFishTriggers && vibration > vibrationThreshold && !motorTriggered) {
      triggerCount++;
      for (let i = 0; i < 6; i++) pellets.push(new Pellet(Math.random() * canvas.width, -10));
      motorTriggered = true;
      setTimeout(() => motorTriggered = false, 2000);
    }
    document.getElementById('pointsCount').textContent = fishValues.length;
    document.getElementById('motorCount').textContent = triggerCount;
  }
}

document.getElementById('bleButton').onclick = async () => {
  if (!bleDevice) {
    try {
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ services: ['0000ffe0-0000-1000-8000-00805f9b34fb'] }]
      });
      bleDevice = device;
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('0000ffe0-0000-1000-8000-00805f9b34fb');
      bleCharacteristic = await service.getCharacteristic('0000ffe1-0000-1000-8000-00805f9b34fb');
      await bleCharacteristic.startNotifications();
      bleCharacteristic.addEventListener('characteristicvaluechanged', handleData);
      document.getElementById('bleButton').textContent = 'Disconnect Device';
    } catch (e) {
      alert('Failed to connect: ' + e);
    }
  } else {
    if (bleDevice.gatt.connected) bleDevice.gatt.disconnect();
    bleDevice = null;
    bleCharacteristic = null;
    document.getElementById('bleButton').textContent = 'Connect Device';
  }
};

document.getElementById('fullscreenButton').onclick = () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    fullscreenButton.textContent = 'Exit Fullscreen';
  } else {
    document.exitFullscreen();
    fullscreenButton.textContent = 'Fullscreen';
  }
};

animate();
</script>
</body>
</html>
